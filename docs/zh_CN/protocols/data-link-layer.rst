==========
数据链路层
==========

.. note::
    为了简化接下来的讨论，我们站在物理层的基础上，所有数据发送省略控制比特 ``1010`` 和 ``0101`` 。

前一节讨论了一个理想化模型——两服务器通讯。
现在，我们把问题进一步拓展一下：多台机器如何实现两两通讯？

多服务器通讯问题
================

下面，以三台服务器为例：

.. figure:: /_images/protocols/data-link-layer/2191e6281e268396eaf4d18303ab9fb5.png

    *多服务器通讯模型：共用信道*

图中，有 ``3`` 台服务器，名字分别是： ``ant`` 、 ``bee`` 以及 ``cicada`` 。
为了通讯，我们设想三者均连接至一根共用导线，每台服务器都可以改变导线电平，也可以检测导线电平。
进一步假设，在硬件层面，多机器冲突仲裁机制已经实现并且可用。
这样，是否解决了多服务器通讯问题？

寻址
----

假设， ``ant`` 向 ``bee`` 发送(粗体)一个数据 ``11110000`` 。
由于导线是共享的，所有机器都可以检测到电平信号。
换句话讲， ``bee`` 和 ``cicada`` 都会收到这个数据 ``11110000`` ，而 ``cicada`` 本不应该接收这个数据！
另一方面， ``bee`` 收到数据后，也不知道数据到底是谁发送给它的。

.. figure:: /_images/protocols/data-link-layer/129372fbd3cfab17acedd6632303680d.png

    *数据的困惑：我从哪来？要到哪去？*

因此，我们需要引入一些比特，用来标识数据的来源以及目的地。
我们的例子只有3台服务器，两个比特就足以唯一确定一台机器：

.. csv-table::
    :header: "机器", "比特"

    "ant", "00"
    "bee", "01"
    "cicada", "10"

那么，发送数据时，额外加上两个比特用于表示来源机器，另外两个比特表示目标机器，问题不就解决了吗？

.. figure:: /_images/protocols/data-link-layer/c40d1f04fd8f51b47cab3a2387d50bfa.png

``bee`` 收到数据后，检查前两个比特(红色)，值为 ``00`` ，便知道是 ``ant`` 发出来的；
检查紧接着的两个比特(绿色)，值为 ``01`` ，与自己匹配上，便愉快地收下了。
相反， ``cicada`` 收到数据后，发现 ``01`` 和自己 ``10`` 匹配不上，便丢弃这个数据。

新引入比特所起的作用，在计算机网络中称为 **寻址** 。
这两个比特也就称为 **地址** ，其中，红色为源地址，绿色为目的地址。
通过引入寻址，我们完美地解决了数据从哪来，到哪去的问题。

复用/分用
---------

信道只有一个，但是通讯需求是无穷无尽的——传输研究数值、文件打印、即时通讯，不一而足。
如何解决这个矛盾呢？套路还是一样的——引入新的比特。

假设，总的通讯需求就上面这3个，那么，2个额外的比特便解决了问题。

.. csv-table::
    :header: "类型", "比特"

    "研究数据", "00"
    "文件打印", "01"
    "即时通讯", "10"

这时，假设 ``ant`` 向 ``bee`` 上报研究数据并打印一个文件：

.. figure:: /_images/protocols/data-link-layer/9c11e1fe6649cd4d5fb31a0869cf6545.png

    *信道复用：使用额外比特区分数据类型*

这样，通过新引入的紫色比特，我们实现了在同个信道上进行不同的通讯！
``bee`` 接收到数据后，根据紫色比特，决定数据如何处理。

接下来，从理论的视角来审视这个场景：

.. figure:: /_images/protocols/data-link-layer/967793342e62b831ef0ff7127a4b6537.png

    *复用/分用*

信道只有一个，需要承载不同的通讯需求。
在发送端，通过加入紫色比特，将不同的数据放在通过一个共用信道发送出去，这个过程叫做 **复用** ( ``Multiplexing`` )；
在接收端，从共用信道上接收数据，然后检查紫色比特决定数据如何处理，这个过程叫做 **分用** ( ``Demultiplexing`` )。
在接下来的章节，我们将看到 ``复用`` - ``分用`` 这个概念贯彻计算机网络的始终。

到目前为止，我们引入了 ``3`` 种不同的比特，分别是 **源地址** 、 **目的地址** 以及 **数据类型** 。
对于这些比特的位数以及含义的约定，便成为 **网络协议** 。

以太网
======

我们虚构了一个网络协议，用于解决数据链路层面临的主要问题。
接下来，介绍一个真实的数据链路层协议—— **以太网协议** 。
**以太网协议** 格式如下(注意这里的单位为字节而不是比特了)：

.. figure:: /_images/protocols/data-link-layer/97c13f044de260baf0ed8051091dd251.png

    *以太网帧：目的地址、源地址、类型、数据、校验和*

是不是有种似曾相识的感觉！
首先，是一个6个字节长的目的地址，用于标记数据由哪台机器接收；
紧接着，是一个6个字节长的源地址，用于标记数据由哪台机器发送；
再接着，是一个2个字节长的类型，用于标记数据包该如何处理， ``0x0800`` 表示承载的是一个 ``IP`` 包(后续介绍)；
再接着是长度不固定的数据( ``Payload`` )；
最后，是一个4个自己长的检验和，用于检测数据传输中的引入的错误。
哈哈，跟我们假设的套路一模一样！

结论
====

本节，我们解决了多台共用信道服务器间的通信问题，这相当于网络分层结构中的 **数据链路层** 。
数据链路层的主要作用包括：

- 寻址
- 复用/分用

我们还学习了一个数据链路层网络协议—— **以太网协议** ，以太网协议的通信单位为 **帧** ( ``Frame`` )。
一个 **以太网帧** 由 **头部** 、 **数据** 以及 **检验和** ``3`` 部分组成，而头部又由 **目的地址** 、 **源地址** 以及 **类型** ``3`` 个字段组成。

进度
====

.. figure:: /_images/protocols/data-link-layer/fb28fd42d6a7e8d61ebfab093e8e906d.png

    *新技能Get✔️*
